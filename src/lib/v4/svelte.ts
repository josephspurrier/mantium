interface SElement {
  el: HTMLElement | null;
  ctx: number[];
  dirty: number[];
  update: (index: number) => void;
}

// mimics the internal svelte component structure: https://github.com/sveltejs/svelte/blob/master/src/runtime/internal/Component.ts#L105
const mySvelte: SElement = {
  el: null, // if you check the html part, it starts as 0 there

  ctx: [] as number[], // holds the variables/functions inside the component
  dirty: [] as number[], // temporary holds the index of the fields that changed in the last tick

  // mimics a svelte update function, generated by the compiler
  update: (index: number) => {
    if (index === 0) {
      if (mySvelte.el) {
        mySvelte.el.textContent = String(mySvelte.ctx[index]);
      }
    }
  },
};

// mimics the svelte scheduler: https://github.com/sveltejs/svelte/blob/master/src/runtime/internal/scheduler.ts
let dirty_components: SElement[] = []; // holds the dirty components, that will be rendered on the next tick
let update_scheduled = false; // the flag to control a single update cycle at a time

function schedule_update() {
  if (!update_scheduled) {
    // if we dont have a update cycle yet
    update_scheduled = true; // we will have one scheduled

    console.log('scheduled!');

    // svelte uses promise.resolve to do all changes on the next tick
    void Promise.resolve().then(() => {
      console.log('Promise ran!');
      // one by one the components will be updated, only the dirty fields of course
      dirty_components.forEach((component) => {
        component.dirty.forEach(component.update); // svelte use bitwise operations on the update fn instead loop, to be faster

        component.dirty = []; // empty the list of dirty attrs
      });

      dirty_components = []; // empty the list of dirty comps

      update_scheduled = false; // we can now schedule a new update to happen on another future tick
    });
  }
}

// mimics $$invalidate function to trigger an update: https://github.com/sveltejs/svelte/blob/master/src/runtime/internal/Component.ts#L130
function invalidate(index: number, newValue: number) {
  if (mySvelte.ctx[index] !== newValue) {
    // if the new value is different than the value on the context
    mySvelte.ctx[index] = newValue; // we add it to the component context, to update later

    mySvelte.dirty.push(index); // we push the dirty attr to the list, so we can do only new operations

    dirty_components.push(mySvelte); // svelte adds the component to the dirty list
    schedule_update(); // schedule a update to happen next tick
  }
}

export function svelteRun(parent: HTMLElement): void {
  mySvelte.el = parent;
  // mimics a component initialization, mapping the variables, functions, etc, to the component context
  let n = 1;
  mySvelte.ctx[0] = n;

  invalidate(0, (n += 1)); // it changes the context and schedule an update
  console.log('Value 1:', mySvelte.el?.textContent); // it prints 0

  invalidate(0, (n += 1)); // it just changes the context cause the update was already scheduler
  console.log('Value 2:', mySvelte.el?.textContent); // it prints 0

  console.log('Changes planned');

  // the previous block runs syncronously, so the scheduler didnt run yet
  setTimeout(() => {
    console.log('Timeout ran');
    console.log(mySvelte.el?.textContent); // it prints 3
  });

  console.log('Code Finished');
}
